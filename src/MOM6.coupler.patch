From 9c4d9ad53d48d0818d0c2e9e218e3dd1b76bf94a Mon Sep 17 00:00:00 2001
From: Travis Sluka <travis.sluka@noaa.gov>
Date: Mon, 18 Sep 2017 10:33:17 -0400
Subject: [PATCH 1/1] modified surface forcing to optionally use fixed
 atmospheric levels set in namelist that are different for T/q and U/V fields

---
 surface_flux.F90 | 153 ++++++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 113 insertions(+), 40 deletions(-)

diff --git a/surface_flux.F90 b/surface_flux.F90
index 7f0a9a8..dc85fac 100644
--- a/surface_flux.F90
+++ b/surface_flux.F90
@@ -177,7 +177,10 @@ logical :: ncar_ocean_flux_orig  = .false. !< Use NCAR climate model turbulent f
                                            !! new experiments.
 logical :: raoult_sat_vap        = .false. !< Reduce saturation vapor pressure to account for seawater
 logical :: do_simple             = .false.
-
+real    :: fixed_z_atm_tq        = -1      !< a fixed value in meters to use for the atmospheric T/q heights
+                                           !! If -1 use the 2D z_atm field
+real    :: fixed_z_atm_uv        = -1      !< a fixed value in meters to use for the atmospheric wind heights
+                                           !! If -1 use the 2D z_atm field
 
 namelist /surface_flux_nml/ no_neg_q,             &
                             use_virtual_temp,     &
@@ -189,7 +192,9 @@ namelist /surface_flux_nml/ no_neg_q,             &
                             ncar_ocean_flux,      &
                             ncar_ocean_flux_orig, &
                             raoult_sat_vap,       &
-                            do_simple
+                            do_simple,            &
+                            fixed_z_atm_uv,       &
+                            fixed_z_atm_tq
 
 
 
@@ -217,7 +222,7 @@ subroutine surface_flux_1d (                                           &
                                      u_atm, & !< Zonal wind velocity at lowest atmospheric level.
                                      v_atm, & !< Meridional wind velocity at lowest atmospheric level.
                                      p_atm, & !< Pressure lowest atmospheric level.
-                                     z_atm, & !< Height lowest atmospheric level.
+                                     z_atm, & !< Height lowest atmospheric level, this can be overriden by namelist settings
                                      t_ca, & !< Air temp at the canopy
                                      p_surf, & !< Pressure at the Earth's surface
                                      t_surf, & !< Temp at the Earth's surface
@@ -261,10 +266,23 @@ subroutine surface_flux_1d (                                           &
        e_sat,    e_sat1,   q_sat,     q_sat1,    p_ratio,  &
        t_surf0,  t_surf1,  u_dif,     v_dif,               &
        rho_drag, drag_t,    drag_m,   drag_q,    rho,      &
-       q_atm,    q_surf0,  dw_atmdu,  dw_atmdv,  w_gust
+       q_atm,    q_surf0,  dw_atmdu,  dw_atmdv,  w_gust,   &
+       t_atm_uv, q_atm_uv, z_atm_tq,  z_atm_uv, t_star
 
   integer :: i, nbad
 
+  ! either read in the atm height from single value of namelist or the z_atm field given
+  if (fixed_z_atm_tq > 0) then
+     z_atm_tq = fixed_z_atm_tq
+  else
+     z_atm_tq = z_atm
+  end if  
+  if (fixed_z_atm_uv > 0) then
+     z_atm_uv = fixed_z_atm_uv
+  else
+     z_atm_uv = z_atm
+  end if
+
 
   if (.not. module_is_initialized) &
      call mpp_error(FATAL, "surface_flux_1d: surface_flux_init is not called")
@@ -359,20 +377,40 @@ subroutine surface_flux_1d (                                           &
      endwhere
   endif
 
-  !  monin-obukhov similarity theory
-  call mo_drag (thv_atm, thv_surf, z_atm,                  &
+  ! initialize first guess of t/q at wind level with t/q given at t/q level
+  ! these values will change after calling mo_drag and ncar_ocean_fluxes
+  ! as t/q are properly moved to wind levels.
+  t_atm_uv = t_atm
+  q_atm_uv = q_atm
+
+  ! monin-obukhov similarity theory
+  ! do 2 iterations
+  call mo_drag (thv_atm, thv_surf, z_atm_uv,               &
        rough_mom, rough_heat, rough_moist, w_atm,          &
        cd_m, cd_t, cd_q, u_star, b_star, avail             )
+  where(avail)
+     ! NOTE, this is only guaranteed to be accurate if mo_drag was run with
+     ! neutral stability
+     t_star = (cd_t/sqrt(cd_m))*(t_atm-t_surf0)
+     q_star = (cd_q/sqrt(cd_m))*(q_atm-q_surf0)
+     t_atm_uv = t_atm - t_star*log(z_atm_tq/z_atm_uv)/vonkarm
+     q_atm_uv = q_atm - q_star*log(z_atm_tq/z_atm_uv)/vonkarm
+  end where
 
   ! override with ocean fluxes from NCAR calculation
   if (ncar_ocean_flux .or. ncar_ocean_flux_orig) then
-    call  ncar_ocean_fluxes (w_atm, th_atm, t_surf0, q_atm, q_surf0, z_atm, &
-                             seawater, cd_m, cd_t, cd_q, u_star, b_star     )
+    call  ncar_ocean_fluxes (w_atm, th_atm, t_surf0, q_atm, q_surf0, z_atm_tq, z_atm_uv, &
+                             seawater, cd_m, cd_t, cd_q, u_star, b_star, t_atm_uv, q_atm_uv )
   end if
 
   where (avail)
+     !update with t/q values that were moved to the wind level
+     tv_atm  = t_atm_uv  * (1.0 + d608*q_atm_uv)  ! virtual temperature
+     th_atm  = t_atm_uv  * p_ratio                ! potential T, using p_surf as refernce
+     thv_atm = tv_atm * p_ratio                   ! virt. potential T, using p_surf as reference
+
      ! scale momentum drag coefficient on orographic roughness
-     cd_m = cd_m*(log(z_atm/rough_mom+1)/log(z_atm/rough_scale+1))**2
+     cd_m = cd_m*(log(z_atm_uv/rough_mom+1)/log(z_atm_uv/rough_scale+1))**2
      ! surface layer drag coefficients
      drag_t = cd_t * w_atm
      drag_q = cd_q * w_atm
@@ -389,7 +427,7 @@ subroutine surface_flux_1d (                                           &
 
      ! evaporation
      rho_drag  =  drag_q * rho
-     flux_q    =  rho_drag * (q_surf0 - q_atm) ! flux of water vapor  (Kg/(m**2 s))
+     flux_q    =  rho_drag * (q_surf0 - q_atm_uv) ! flux of water vapor  (Kg/(m**2 s))
 
      where (land)
         dedq_surf = rho_drag
@@ -403,7 +441,7 @@ subroutine surface_flux_1d (                                           &
 
      q_star = flux_q / (u_star * rho)             ! moisture scale
      ! ask Chris and Steve K if we still want to keep this for diagnostics
-     q_surf = q_atm + flux_q / (rho*cd_q*w_atm)   ! surface specific humidity
+     q_surf = q_atm_uv + flux_q / (rho*cd_q*w_atm)   ! surface specific humidity
 
      ! upward long wave radiation
      flux_r    =   stefan*t_surf**4               ! (W/m**2)
@@ -703,15 +741,16 @@ end subroutine surface_flux_init
 !! Update Jul2007: GFDL.Climate.Model.Info@noaa.gov (ch and ce exchange coeff bugfix)
 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
 !
-subroutine ncar_ocean_fluxes (u_del, t, ts, q, qs, z, avail, &
-                              cd, ch, ce, ustar, bstar       )
-real   , intent(in)   , dimension(:) :: u_del, t, ts, q, qs, z
+subroutine ncar_ocean_fluxes (u_del, t, ts, q, qs, z_tq, z_uv, avail, &
+                              cd, ch, ce, ustar, bstar, t_uv, q_uv    )
+real   , intent(in)   , dimension(:) :: u_del, t, ts, q, qs, z_tq, z_uv
 logical, intent(in)   , dimension(:) :: avail
 real   , intent(inout), dimension(:) :: cd, ch, ce, ustar, bstar
+real   , intent(inout), dimension(:) :: t_uv, q_uv
 
   real :: cd_n10, ce_n10, ch_n10, cd_n10_rt    ! neutral 10m drag coefficients
   real :: cd_rt                                ! full drag coefficients @ z
-  real :: zeta, x2, x, psi_m, psi_h            ! stability parameters
+  real :: zeta_tq, zeta_uv, x2, x, psi_m, psi_h_tq, psi_h_uv            ! stability parameters
   real :: u, u10, tv, tstar, qstar, z0, xx, stab
   integer, parameter :: n_itts = 2
   integer               i, j
@@ -739,33 +778,50 @@ real   , intent(inout), dimension(:) :: cd, ch, ce, ustar, bstar
                 tstar    = (ch(i)/cd_rt)*(t(i)-ts(i));                ! L-Y eqn. 7b
                 qstar    = (ce(i)/cd_rt)*(q(i)-qs(i));                ! L-Y eqn. 7c
                 bstar(i) = grav*(tstar/tv+qstar/(q(i)+1/0.608));
-                zeta     = vonkarm*bstar(i)*z(i)/(ustar(i)*ustar(i)); ! L-Y eqn. 8a
-                zeta     = sign( min(abs(zeta),10.0), zeta );         ! undocumented NCAR
-                x2 = sqrt(abs(1-16*zeta));                            ! L-Y eqn. 8b
+                x        = vonkarm*bstar(i)/(ustar(i)*ustar(i))       ! using x temporarily
+                zeta_uv   = x * z_uv(i)                               ! L-Y eqn. 8a
+                zeta_uv   = sign( min(abs(zeta_uv),10.0), zeta_uv );  ! undocumented NCAR
+                zeta_tq   = x * z_tq(i)                               ! L-Y eqn. 8a
+                zeta_tq   = sign( min(abs(zeta_tq),10.0), zeta_tq );  ! undocumented NCAR
+
+                x2 = sqrt(abs(1-16*zeta_uv));                         ! L-Y eqn. 8b
                 x2 = max(x2, 1.0);                                    ! undocumented NCAR
                 x = sqrt(x2);
-
-                if (zeta > 0) then
-                    psi_m = -5*zeta;                                    ! L-Y eqn. 8c
-                    psi_h = -5*zeta;                                    ! L-Y eqn. 8c
+                if (zeta_uv > 0) then
+                    psi_m = -5*zeta_uv;                                 ! L-Y eqn. 8c
+                    psi_h_uv = -5*zeta_uv;                              ! L-Y eqn. 8c
                 else
                     psi_m = log((1+2*x+x2)*(1+x2)/8)-2*(atan(x)-atan(1.0)); ! L-Y eqn. 8d
-                    psi_h = 2*log((1+x2)/2);                                ! L-Y eqn. 8e
+                    psi_h_uv = 2*log((1+x2)/2);                             ! L-Y eqn. 8e
                 end if
 
-                u10 = u/(1+cd_n10_rt*(log(z(i)/10)-psi_m)/vonkarm);       ! L-Y eqn. 9
+                x2 = sqrt(abs(1-16*zeta_tq));                             ! L-Y eqn. 8b
+                x2 = max(x2, 1.0);                                        ! undocumented NCAR
+                if (zeta_tq > 0) then
+                    psi_h_tq = -5*zeta_tq;                                ! L-Y eqn. 8c
+                else
+                    psi_h_tq = 2*log((1+x2)/2);                           ! L-Y eqn. 8e
+                end if
+
+                u10 = u/(1+cd_n10_rt*(log(z_uv(i)/10)-psi_m)/vonkarm);    ! L-Y eqn. 9
+                x = (log(z_tq(i)/z_uv(i))+psi_h_uv-psi_h_tq) / vonkarm    ! use x temporaril
+                t_uv(i) = t(i) - tstar*x                                  ! L-Y eqn. 9b
+                q_uv(i) = q(i) - qstar*x                                  ! L-Y eqn. 9b
+
                 cd_n10 = (2.7/u10+0.142+0.0764*u10)/1e3;                  ! L-Y eqn. 6a again
                 cd_n10_rt = sqrt(cd_n10);
                 ce_n10 = 34.6*cd_n10_rt/1e3;                              ! L-Y eqn. 6b again
-                stab = 0.5 + sign(0.5,zeta)
+                stab = 0.5 + sign(0.5,zeta_uv)
                 ch_n10 = (18.0*stab+32.7*(1-stab))*cd_n10_rt/1e3;         ! L-Y eqn. 6c again
                 z0 = 10*exp(-vonkarm/cd_n10_rt);                          ! diagnostic
 
-                xx = (log(z(i)/10)-psi_m)/vonkarm;
+                xx = (log(z_uv(i)/10)-psi_m)/vonkarm;
                 cd(i) = cd_n10/(1+cd_n10_rt*xx)**2;                       ! L-Y 10a
-                xx = (log(z(i)/10)-psi_h)/vonkarm;
+                xx = (log(z_uv(i)/10)-psi_h_uv)/vonkarm;
                 ch(i) = ch_n10/(1+ch_n10*xx/cd_n10_rt)**2;                !     10b (this code is wrong)
                 ce(i) = ce_n10/(1+ce_n10*xx/cd_n10_rt)**2;                !     10c (this code is wrong)
+
+                tv = t_uv(i) * (1+0.608*q_uv(i)) ! recompute virtual potential temp at z_uv level
              end do
          end if
       end do
@@ -793,33 +849,50 @@ real   , intent(inout), dimension(:) :: cd, ch, ce, ustar, bstar
                 tstar    = (ch(i)/cd_rt)*(t(i)-ts(i));                ! L-Y eqn. 7b
                 qstar    = (ce(i)/cd_rt)*(q(i)-qs(i));                ! L-Y eqn. 7c
                 bstar(i) = grav*(tstar/tv+qstar/(q(i)+1/0.608));
-                zeta     = vonkarm*bstar(i)*z(i)/(ustar(i)*ustar(i)); ! L-Y eqn. 8a
-                zeta     = sign( min(abs(zeta),10.0), zeta );         ! undocumented NCAR
-                x2 = sqrt(abs(1-16*zeta));                            ! L-Y eqn. 8b
+                x        = vonkarm*bstar(i)/(ustar(i)*ustar(i))       ! using x temporarily
+                zeta_uv     = x * z_uv(i)                             ! L-Y eqn. 8a
+                zeta_uv     = sign( min(abs(zeta_uv),10.0), zeta_uv ) ! undocumented NCAR
+                zeta_tq     = x * z_tq(i)                             ! L-Y eqn. 8a
+                zeta_tq     = sign( min(abs(zeta_tq),10.0), zeta_tq ) ! undocumented NCAR
+
+                x2 = sqrt(abs(1-16*zeta_uv));                         ! L-Y eqn. 8b
                 x2 = max(x2, 1.0);                                    ! undocumented NCAR
                 x = sqrt(x2);
-
-                if (zeta > 0) then
-                    psi_m = -5*zeta;                                    ! L-Y eqn. 8c
-                    psi_h = -5*zeta;                                    ! L-Y eqn. 8c
+                if (zeta_uv > 0) then
+                    psi_m = -5*zeta_uv;                                   ! L-Y eqn. 8c
+                    psi_h_uv = -5*zeta_uv;                                ! L-Y eqn. 8c
                 else
-                    psi_m = log((1+2*x+x2)*(1+x2)/8)-2*(atan(x)-atan(1.0)); ! L-Y eqn. 8d
-                    psi_h = 2*log((1+x2)/2);                                ! L-Y eqn. 8e
+                    psi_m = log((1+2*x+x2)*(1+x2)/8)-2*(atan(x)-atan(1.0))! L-Y eqn. 8d
+                    psi_h_uv = 2*log((1+x2)/2);                           ! L-Y eqn. 8e
                 end if
 
-                u10 = u/(1+cd_n10_rt*(log(z(i)/10)-psi_m)/vonkarm);       ! L-Y eqn. 9
+                x2 = sqrt(abs(1-16*zeta_tq))                              ! L-Y eqn. 8b
+                x2 = max(x2, 1.0)                                         ! undocumented NCAR
+                if (zeta_tq > 0) then
+                   psi_h_tq = -5*zeta_tq                                  ! L-Y eqn. 8c
+                else
+                   psi_h_tq = 2*log((1+x2)/2)                             ! L-Y eqn. 8e 
+                endif
+
+                u10 = u/(1+cd_n10_rt*(log(z_uv(i)/10)-psi_m)/vonkarm);    ! L-Y eqn. 9a
+                x = (log(z_tq(i)/z_uv(i))+psi_h_uv-psi_h_tq) / vonkarm    ! use x temporarily
+                t_uv(i) = t(i) - tstar*x                                  ! L-Y eqn. 9b
+                q_uv(i) = q(i) - qstar*x                                  ! L-Y eqn. 9c
+
                 cd_n10 = (2.7/u10+0.142+0.0764*u10)/1e3;                  ! L-Y eqn. 6a again
                 cd_n10_rt = sqrt(cd_n10);
                 ce_n10 = 34.6*cd_n10_rt/1e3;                              ! L-Y eqn. 6b again
-                stab = 0.5 + sign(0.5,zeta)
+                stab = 0.5 + sign(0.5,zeta_uv)
                 ch_n10 = (18.0*stab+32.7*(1-stab))*cd_n10_rt/1e3;         ! L-Y eqn. 6c again
                 z0 = 10*exp(-vonkarm/cd_n10_rt);                          ! diagnostic
 
-                xx = (log(z(i)/10)-psi_m)/vonkarm;
+                xx = (log(z_uv(i)/10)-psi_m)/vonkarm;
                 cd(i) = cd_n10/(1+cd_n10_rt*xx)**2;                       ! L-Y 10a
-                xx = (log(z(i)/10)-psi_h)/vonkarm;
+                xx = (log(z_uv(i)/10)-psi_h_uv)/vonkarm;
                 ch(i) = ch_n10/(1+ch_n10*xx/cd_n10_rt)*sqrt(cd(i)/cd_n10) ! 10b (corrected code)
                 ce(i) = ce_n10/(1+ce_n10*xx/cd_n10_rt)*sqrt(cd(i)/cd_n10) ! 10c (corrected code)
+
+                tv = t_uv(i) * (1+0.608*q_uv(i)); ! recompute virtual potential temp at z_uv level
              end do
          end if
       end do
-- 
2.9.3

